# NPML 翻译请求文

## NPML代码:
[1] (prefix){
[2]     (目标语言：markdown)
[3]     (描述：编写整个项目的README文档)
[4]     (文件输出名：README.md,README_EN.md)
[5] }
[6] 
[7] (引用){
[8]     !(docs/project.md)
[9]     !(docs/feats/1-1&1.3.md)
[10]     !(docs/feats/1-4.md)
[11]     !(docs/feats/1-5.md)
[12]     !(docs/apis/1-6-api.md)
[13] }
[14] 
[15] (编写NPML翻译器项目README文档){
[16]     (有中文、英文两个版本){
[17]         (默认中文版本->README.md)
[18]         (英文版本->README_EN.md)
[19]     }
[20]     (项目背景、目的)
[21]     (安装方式){
[22]         !(deno.json)
[23]     }
[24]     (npml CLI命令使用教程)
[25]     (关于NPML的概念){
[26]         !(docs/about_npml.md)
[27]     }
[28]     (贡献说明){
[29]         (欢迎贡献代码、优化NPML翻译器和NPML的本身设计)
[30]     }
[31] }

## 引用内容:
// docs/project.md
[1] # NPML翻译器 项目文档
[2] 版本：v0.0.1
[3] 接收NPML代码，输出NPML翻译请求文。
[4] 基于deno+ts。
[5] 
[6] ## 一、项目功能
[7] ### 1.1 文件按行读取
[8] 读取文件时，可读取指定行数范围的文件内容。如果行数范围省略，则读取全部内容。
[9] ### 1.2 文件内容类[废弃，不开发]
[10] 实现一个存储和管理已读取的文件内容类。
[11] ### 1.3 文件内容行号显示
[12] 给文件内容的每一行开头增加行号，例如：
[13] ```python
[14] [1]def main():
[15] [2]    print("Hello NPML!")
[16] ```
[17] ### 1.4 NPML引用内容读取
[18] 在NPML代码中（已经读取的文件内容）会有形如：
[19] ```text
[20] !(docs/project.md)
[21] !(../routes/login.tsx)
[22] !(docs/libs/start.md#5)
[23] !(docs/fresh/islands.md#12:36)
[24] ```
[25] 这样的引用内容语法标记。以感叹号开头，括号里面为引用内容文件地址（绝对或者相对）。文件地址后面#指明具体的行数范围。
[26] #<from>:<to>表示读取第from行到第to行的引用内容。如果只有#<number>表示只读取第number行内容。
[27] 如果没有#则读取全部引用内容。
[28] 提取并读取NPML代码中所有引用内容。
[29] 
[30] ### 1.5 指定目录结构树生成
[31] 指定某个存在的目录路径，遍历其中所有文件夹和文件，生成一个目录树，形如：
[32] ```text
[33] docs/
[34]     libs/
[35]         fresh/
[36]     project.md
[37] routes/
[38]     api/
[39]     index.tsx
[40] islands/
[41] deno.json
[42] main.ts
[43] ```
[44] .开头的文件夹跳过遍历，如.git、.vscode、.venv等。
[45] ### 1.6 NPML翻译请求文生成（文件内容聚合）
[46] NPML翻译请求文格式如下：
[47] ```text
[48] NPML代码:
[49] [正文]
[50] 项目结构说明:
[51] [正文]
[52] 引用内容:
[53] [正文1]
[54] ---
[55] [正文2]
[56] ---
[57] ...
[58] ```
[59] 指定某个NPML代码文件路径后，读取文件，并标上行号；
[60] 读取NPML代码中的所有引用内容，也标上行号；
[61] 生成指定目录路径的目录树（如果没有指明目录路径，省略为空）；
[62] 在每个引用内容顶部加上：
[63] ```text
[64] // docs/project.md
[65] ```
[66] 指明文件路径和文件名。多个引用内容之间用---隔开。
[67] 将上面内容按照NPML翻译请求文聚合整理为一个markdown文档。
[68] 最后的md文档有2种输出方式：
[69] - 文件输出：在当前目录下输出该md文档，文件名为npml代码文件名；
[70] - 剪切板输出：将md文档复制到剪切板上。
[71] 
[72] ### 1.7 CLI工具
[73] 实现2.1 项目架构中的CLI工具。
[74] 
[75] 
[76] ## 二、项目架构和运行流程
[77] ### 2.1 项目架构
[78] 项目为CLI工具，即运行在命令行的工具，通过指明参数来运行。
[79] CLI工具名为npml，参数如下：
[80] npml [npml_file_name]   :例如npml main.npml,在当前运行目录下生成npml翻译请求文的md文档。
[81] npml -v                 :显示当前npml翻译器版本。
[82] npml -h                 :显示参数使用说明。
[83] npml -c                 :将npml翻译请求文复制到剪切板上，不生成md文档。
[84] npml -t [dir_path]      :指明需要生成目录树的目录路径。
[85] npml -dr                :不读取npml代码的引用内容。
[86] 
[87] ### 2.2 项目运行流程
[88] 执行命令npml main.npml的项目运行流程如下：
[89] - 读取main.npml的所有内容，并标上行号（1.1功能、1.3功能）；
[90] - 读取main.npml中所有引用内容，每个引用文件标上行号（1.1功能、1.4功能）；
[91] - 如果使用-t参数，生成指定目录的目录树（1.5功能）；
[92] - 生成最终的npml翻译请求文md文档（1.6功能）。
[93] 
[94] ## 三、项目开发范式
[95] 单一职责原则；
[96] 关注点分离；
[97] 依赖注入风格；
[98] 模块化设计；
[99] 组合大于继承。
---
// docs/feats/1-1&1.3.md
[1] 文件名
[2] file_reader.ts
[3] 
[4] 功能概述
[5] 实现文件按行读取功能（功能1.1）和为文件内容添加行号前缀功能（功能1.3）。接收包含路径和可选行号范围的字符串，读取指定文件内容（或其指定范围），并为每一行添加[行号]前缀后返回。
[6] 
[7] 类、接口、函数的签名和功能
[8] 
[9] 类：FileReader
[10] 核心文件读取和行号标注类。
[11] 
[12] 方法：private parsePathWithRange(filePathWithRange: string): { filePath: string; startLine: number | null; endLine: number | null } | null
[13] - 功能：解析包含路径和行号范围的字符串。
[14] - 输入：filePathWithRange - 格式如 path/to/file.txt, path/to/file.txt#2, path/to/file.txt#2:5 的字符串。
[15] - 输出：成功时返回包含解析出的文件路径、起始行号、结束行号的对象；格式无效时返回 null。
[16] 
[17] 方法：async readFile(filePathWithRange: string): Promise
[18] - 功能：根据路径和可选范围读取文件内容，并为每行添加行号前缀。
[19] - 输入：filePathWithRange - 指定文件路径和可选行号范围的字符串。
[20] - 输出：Promise - 成功时返回带行号前缀的文件内容字符串；失败（文件不存在、读取错误、格式无效）时返回 null。
[21] 
[22] 实现细节概述
[23] 1.  路径与范围解析：parsePathWithRange 方法通过 # 分割字符串获取路径和范围部分。范围部分再通过 : 分割获取起始和结束行号。对行号进行有效性校验（正整数、起始不大于结束）。
[24] 2.  文件读取：使用 Deno.readTextFile 异步读取文件内容。使用 try...catch 块捕获文件不存在或读取错误，并打印错误信息到控制台。
[25] 3.  内容处理：将读取到的文件内容按 r?n 分割成行数组，以兼容不同操作系统换行符。
[26] 4.  行范围处理：根据解析出的 startLine 和 endLine（1-based）计算出在数组中的索引范围（0-based），并使用 slice 提取指定范围的行。
[27] 5.  行号添加：遍历最终确定的行数组，使用 map 为每一行添加 [行号] 前缀，行号基于原始文件的行号（1-based）。
[28] 6.  结果返回：将处理后的带行号的行数组用 n 连接成字符串返回。
[29] 
[30] 功能测试内容
[31] 1.  完整文件读取：测试读取不带行号范围的文件，验证返回内容包含所有行及正确的行号。
[32] 2.  单行读取：测试 #N 格式，验证只返回第 N 行且带有正确行号。
[33] 3.  多行范围读取：测试 #N1:N2 格式，验证返回 N1 到 N2 行的内容及对应行号。
[34] 4.  超出范围读取：测试请求的行号超出文件实际行数的情况，验证返回实际存在的行。
[35] 5.  空文件读取：测试读取空文件，验证返回空字符串 ""。
[36] 6.  文件不存在：测试读取不存在的文件路径，验证返回 null 并打印错误信息。
[37] 7.  路径格式错误：测试无效的 filePathWithRange 格式（如 #abc、path#1:2:3、path#2:1），验证返回 null。
[38] 8.  行号无效：测试行号为非数字、负数或零的情况，验证返回 null。
[39] 9.  行号边界：测试 #0、#-1 等边界情况，验证返回 null。
[40] 
[41] 与其他功能的关系
[42] - 功能 1.2 (文件内容管理)：已被废弃，不开发。
[43] - 功能 1.4 (解析NPML引用)：FileReader 依赖功能 1.4 提供的 filePathWithRange 字符串来执行具体的文件读取操作。
[44] - 功能 1.6 (生成NPML翻译请求文)：功能 1.6 在聚合文件内容时，需要调用 FileReader 来读取原始NPML文件及其所有引用文件的内容。
---
// docs/feats/1-4.md
[1] 功能 1.4 开发文档：NPML引用内容读取功能
[2] 
[3] 概述
[4] 本功能负责解析和读取NPML代码中的引用内容。它能够识别NPML代码中特定格式的引用标记（如 !(path/to/file.txt) 或 !(path/to/file.txt#2:5)），提取其中的文件路径和可选的行号范围，然后调用功能1.1（文件按行读取，即FileReader类）来获取指定内容，并为读取到的内容添加行号。
[5] 
[6] 接口与实现类：
[7] - `NPMLReferenceReader`核心类，负责解析NPML内容中的引用标记并读取其内容。
[8] - **接口 `ReferenceResult`**:
[9]   - `path: string` - 原始引用路径（例如 `docs/libs/start.md#5`）。
[10]   - `content: string | null` - 读取到的带行号的文件内容字符串，如果读取失败则为 `null`。
[11] - **方法 `async readReferences(npmlContent: string): Promise<ReferenceResult[]>`**
[12]   - **功能**：解析传入的NPML内容字符串，查找所有符合引用格式的标记，读取每个引用的文件内容（根据可选的行号范围），并为内容添加行号。
[13]   - **返回值**：一个Promise，其结果是一个 `ReferenceResult` 对象的数组。
[14]   - **输入**：`npmlContent: string` - 包含NPML代码及其引用标记的原始字符串。
[15]   - **输出**：`Promise<ReferenceResult[]>`:
[16]     - 成功时，返回一个数组。数组中每个元素是一个 `ReferenceResult` 对象，包含 `path`（原始引用路径）和 `content`（读取到的带行号的文件内容字符串）。
[17]     - 如果某个引用读取失败（如文件不存在），则对应数组元素的 `content` 为 `null`。
[18]     - 如果NPML内容中没有任何引用标记，则返回一个空数组 `[]`。
[19] 
[20] 实现细节
[21] 1.  **引用标记解析**：
[22]     - 使用正则表达式 `/!\(([^)]+)\)/g` 来全局匹配NPML内容中所有 `!(...)` 格式的引用标记。
[23]     - 从匹配结果中提取出括号内的内容（例如 `docs/libs/start.md#5`），这将作为 `FileReader` 类的 `readFile` 方法的输入参数。
[24]     - 将所有提取到的引用路径收集到一个数组中。
[25] 2.  **内容读取**：
[26]     - 遍历上一步收集到的引用路径数组。
[27]     - 对于每个路径，实例化或注入 `FileReader` 类（功能1.1）。
[28]     - 调用 `FileReader.readFile(filePathWithRange)` 方法来读取文件内容。`filePathWithRange` 即为当前循环中的引用路径。
[29]     - 将 `FileReader` 返回的结果（带行号的内容字符串或 `null`）与原始引用路径一起，存入一个结果数组。
[30] 3.  **结果聚合**：
[31]     - 返回最终的结果数组。数组的顺序应与NPML内容中引用标记出现的顺序一致。
[32] 
[33] 功能测试
[34] - 无引用内容：测试输入一个不包含任何 `!(...)` 标记的NPML字符串，验证返回一个空数组 `[]`。
[35] - 单个引用：测试输入包含一个引用标记（如 `!(file.txt)`）的NPML字符串，验证返回的数组包含一个 `{ path, content }` 对象，其中 `content` 包含了 `file.txt` 的全部内容并带有行号。
[36] - 多个引用：测试输入包含多个引用标记的NPML字符串，验证返回的数组包含多个 `{ path, content }` 对象，顺序与标记出现顺序一致。
[37] - 引用带行号范围：测试输入包含带行号范围的引用标记（如 `!(file.txt#2:5)`），验证读取到的内容是 `file.txt` 的第2到第5行，并带有正确的行号。
[38] - 引用带单行号：测试输入包含带单行号的引用标记（如 `!(file.txt#3)`），验证读取到的内容是 `file.txt` 的第3行，并带有正确的行号。
[39] - 混合引用：测试输入包含无范围、单行、多行范围的混合引用标记，验证所有引用都能被正确解析和读取。
[40] - 无效引用路径：测试输入包含指向不存在文件的引用标记，验证该引用对应的结果数组元素为 `null`，且 `FileReader` 应打印错误信息。
[41] - 无效引用格式：测试输入包含格式错误的标记（如 `!(file.txt##2)` 或 `!(file.txt#abc:def)`），这些应被视为无效路径并由 `FileReader` 处理返回 `null`。
[42] - 引用内容为空：测试引用一个空文件，验证其对应的 `content` 为 `""`。
[43] - 引用内容包含换行符：确保读取的引用内容能正确处理不同操作系统的换行符，并正确添加行号。
[44] 
[45] 与其他功能的关系
[46] - **功能 1.1 (文件按行读取)**：`NPMLReferenceReader` 直接依赖 `FileReader` 类来执行实际的文件读取和行号添加操作。
[47] - **功能 1.6 (生成NPML翻译请求文)**：功能 1.6 需要调用 `NPMLReferenceReader` 来获取NPML代码中所有引用文件的内容，然后将其聚合到最终的翻译请求文档中。
---
// docs/feats/1-5.md
[1] ### **功能 1.5 开发文档：指定目录结构树生成**
[2] 
[3] **功能概述**
[4] 
[5] 本功能负责根据用户提供的一个本地目录路径，递归遍历该目录下的所有文件和子目录，并以一种清晰的树状格式（类似于 `tree` 命令的输出）生成该目录的结构字符串。此功能是 NPML 翻译请求文生成流程的一部分，用于向翻译器提供项目整体的文件组织结构信息。
[6] 
[7] **接口与实现类**
[8] 
[9] *   **核心类**: `RealDirectoryTreeGenerator`
[10]     *   负责协调目录遍历、结构化表示和格式化输出的逻辑。
[11] *   **方法**: `async generateTree(dirPath: string): Promise<string | null>`
[12]     *   **功能**: 接收一个目录路径，递归扫描其内容，并返回一个格式化的目录树字符串。
[13]     *   **返回值**: 一个 `Promise`，其结果为 `string | null`。成功时，返回一个代表目录结构的字符串。失败时（例如，路径不存在、路径不是目录、或访问被拒绝），返回 `null`。
[14] 
[15] **输入与输出**
[16] 
[17] *   **输入**: `dirPath: string` - 一个指向本地文件系统的目录路径（可以是绝对路径或相对于当前工作目录的相对路径）。
[18] *   **输出**: `Promise<string | null>`
[19]     *   **成功 (`string`)**: 返回一个格式化的字符串，表示目录树。格式应与 `project.md` 中描述的一致，例如：
[20]         ```
[21]         docs/
[22]          libs/
[23]           fresh/
[24]          project.md
[25]         routes/
[26]          api/
[27]           index.tsx
[28]          islands/
[29]         deno.json
[30]         main.ts
[31]         ```
[32]         *   每个目录名后跟 `/`。
[33]         *   使用空格缩进表示层级关系。
[34]         *   文件名不带 `/`。
[35]     *   **失败 (`null`)**: 如果提供的 `dirPath` 不存在、不是一个目录、或由于权限问题无法访问，则返回 `null`。
[36] 
[37] **实现细节**
[38] 
[39] *   **路径验证**:
[40]     *   首先，使用 Deno 标准库（如 `Deno.stat`）检查 `dirPath` 是否存在且为一个目录。如果验证失败，则直接返回 `null`。
[41] *   **递归遍历**:
[42]     *   定义一个内部辅助函数，例如 `traverse(path: string, prefix: string, isLast: boolean): Promise<string>`
[43]         *   `path`: 当前正在遍历的路径。
[44]         *   `prefix`: 用于表示当前层级的缩进和分支符号（如 `├──`, `└──`, `│`）的字符串。
[45]         *   `isLast`: 一个布尔值，表示当前项是否为其父目录中的最后一项，用于决定使用 `├──` 还是 `└──`。
[46]     *   此函数负责读取指定 `path` 下的直接子项（使用 `Deno.readDir`）。
[47]     *   **过滤隐藏目录**: 在读取子项列表后，需要过滤掉名称以 `.` 开头的目录项（例如 `.git`, `.vscode`, `.venv`）。文件不受此规则影响，即使名称以 `.` 开头也会被包含。
[48]     *   对每个子项，判断其是文件还是目录。
[49]     *   根据子项的顺序和是否为最后一个，生成正确的 `prefix` 字符串（例如，如果当前项是最后一个，则下级的前缀应为 `prefix + "   "`；否则为 `prefix + "│  "`）。
[50]     *   如果子项是目录，递归调用自身。
[51]     *   将所有子项的输出拼接起来。
[52] *   **格式化输出**:
[53]     *   主 `generateTree` 函数调用 `traverse` 辅助函数，起始路径为 `dirPath`，起始 `prefix` 为空字符串，`isLast` 为 `true`（因为根目录本身是唯一的）。
[54]     *   `traverse` 函数返回的字符串即为最终的目录树格式化结果。
[55] *   **排序**:
[56]     *   为了保证输出的一致性，建议在遍历每个目录的子项时，先对子项列表（经过隐藏目录过滤后）进行排序（例如，按名称字母顺序排序，目录名在前，文件名在后）。
[57] 
[58] **功能测试**
[59] 
[60] *   **有效目录路径**: 测试一个包含多级子目录、文件以及 `.hidden_dir` 的路径，验证输出的树状结构是否正确反映了实际的文件系统结构，并确认 `.hidden_dir` 及其内容未被包含。
[61] *   **空目录**: 测试一个没有任何子文件或子目录的空目录，验证输出是否为该目录名后跟 `/`。
[62] *   **不存在的路径**: 测试一个不存在的路径，验证函数返回 `null`。
[63] *   **指向文件而非目录的路径**: 测试一个指向文件的路径，验证函数返回 `null`。
[64] *   **权限不足**: 在一个没有读取权限的目录上运行，验证函数返回 `null`。
[65] *   **包含特殊字符的路径**: 测试包含空格、中文或其他特殊字符的路径名，确保遍历和输出正确。
[66] *   **输出格式**: 仔细检查输出的缩进、分支符号（`├──`, `└──`, `│`）是否符合 `project.md` 中描述的树状格式。
[67] 
[68] **与其他功能的关系**
[69] 
[70] *   **功能 1.6 (NPML翻译请求文生成)**: 功能 1.6 会调用 `DirectoryTreeGenerator.generateTree` 来获取项目结构信息。如果 CLI 参数 `-t` 指定了目录，则此功能的输出将被包含在最终生成的 NPML 翻译请求文的 "项目结构说明" 部分。
---
// docs/apis/1-6-api.md
[1] 1-6 功能：NPML 翻译请求文生成（文件内容聚合）
[2] --------------------------------------------------
[3] 一、功能概述  
[4] --------------------------------------------------
[5] 接收一份 `.npml` 源码文件路径，按既定顺序完成以下子任务，最终输出一份可直接交付给翻译模型的 Markdown 聚合文档（或剪贴板文本）：
[6] 
[7] 1. 读取主 NPML 源码并追加行号（复用 1-1 + 1-3）。  
[8] 2. 若命令行显式给出 `-t <dir>`，则生成该目录的层级树（复用 1-5）。  
[9] 3. 若未禁用引用（无 `-dr` 标志），则扫描并读取所有 `!(path[#range])` 引用块，同样追加行号（复用 1-4）。  
[10] 4. 将上述三块内容按固定章节顺序拼接成一份 Markdown 文档。  
[11] 5. 支持两种输出策略：  
[12]    a) 文件输出 – 与输入 `.npml` 同目录、同名、后缀改为 `.md`（新增函数 `fileOutput`）。  
[13]    b) 剪贴板输出 – 将最终文档写入系统剪贴板（目前为 console 占位，预留未来 `Deno.writeText` 或第三方库实现）。  
[14] 
[15] --------------------------------------------------
[16] 二、对应代码 / 配置 / 资源文件
[17] --------------------------------------------------
[18] | 类型 | 路径（相对于项目根） | 说明 |
[19] |---|---|---|
[20] | 核心代码 | `npml_request_generator.ts` | 本功能唯一实现文件 |
[21] | 依赖接口 | `file_reader.ts` | 1-1 功能，提供 `readFile(path):Promise<string|null>` |
[22] | 依赖接口 | `reference_reader.ts` | 1-4 功能，提供 `readReferences(content):Promise<ReferenceResult[]>` |
[23] | 依赖接口 | `directory_tree_generator.ts` | 1-5 功能，提供 `generateTree(dir):Promise<string|null>` |
[24] | 外部库 | `jsr:@std/path` | 用于安全计算输出文件路径 |
[25] | 外部库 | `jsr:@std/fs` | 用于 `ensureFileSync` |
[26] 
[27] --------------------------------------------------
[28] 三、公共 API 清单
[29] --------------------------------------------------
[30] 1. 接口：GenerationOptions  
[31]    描述：控制生成行为的轻量级 DTO。  
[32]    源码位置：`npml_request_generator.ts` 顶部。  
[33] 
[34] ```ts
[35] export interface GenerationOptions {
[36]   /** 若提供，则生成该目录树并写入“项目结构说明”章节 */
[37]   includeDirTree?: string;
[38]   /** true 时跳过引用内容读取（对应 CLI 的 `-dr` 标志） */
[39]   skipReferences?: boolean;
[40]   /** true 时将最终文档复制到剪贴板（对应 CLI 的 `-c` 标志） */
[41]   outputToClipboard?: boolean;
[42] }
[43] ```
[44] 
[45] 2. 类：NpmlRequestGenerator  
[46]    描述：聚合协调器（依赖注入风格）。  
[47]    构造时必须传入三个已实例化的依赖对象，符合“单一职责 & 关注点分离”原则。  
[48] 
[49] ```ts
[50] export class NpmlRequestGenerator {
[51]   constructor(
[52]     private fileReader: FileReader,
[53]     private referenceReader: NPMLReferenceReader,
[54]     private dirTreeGenerator: DirectoryTreeGenerator
[55]   ) {}
[56] 
[57]   /** 核心入口函数 */
[58]   async generateRequest(
[59]     npmlFilePath: string,
[60]     options: GenerationOptions
[61]   ): Promise<string | null>;
[62] }
[63] ```
[64] 
[65] 方法签名与行为：  
[66] - `generateRequest`  
[67]   – 入参：`npmlFilePath` 必须指向可读 `.npml` 文件；`options` 可为空对象（默认全 false）。  
[68]   – 回参：成功返回完整 Markdown 字符串；任一子步骤失败回 `null` 并在控制台打印 `[Error] xxx`。  
[69]   – 副作用：  
[70]     • 若 `outputToClipboard===true`，会打印“--- Content to be copied to clipboard ---”警告（未来可换成真实剪贴板写入）。  
[71]     • 内部不会自动写盘；写盘需调用方再执行 `fileOutput()`。  
[72] 
[73] 3. 纯函数：fileOutput  
[74]    描述：将已生成的 Markdown 内容原子写入磁盘，路径规则“同目录 + 同名 + .md”。  
[75]    签名：
[76] 
[77] ```ts
[78] export function fileOutput(mdContent: string, npmlFilePath: string): string
[79] ```
[80] 
[81] - 返回值为写入后的绝对路径。  
[82] - 若父目录不存在则自动创建；若目标已存在则静默覆盖。  
[83] - 任何 IO 异常直接抛出，由调用方（CLI 主流程）捕获并统一 `Deno.exit(1)`。  
[84] 
[85] --------------------------------------------------
[86] 四、与其他功能的联动关系
[87] --------------------------------------------------
[88] | 本功能步骤 | 使用的外部功能 | 调用方式 | 数据约定 |
[89] |---|---|---|---|
[90] | ① 读取主文件 | 1-1 文件按行读取 | `fileReader.readFile(npmlFilePath)` | 返回 `string|null`；内部已统一追加行号 |
[91] | ② 读取引用块 | 1-4 NPML引用内容读取 | `referenceReader.readReferences(mainContent)` | 返回 `ReferenceResult[]`；内部已追加行号 |
[92] | ③ 生成目录树 | 1-5 目录结构树生成 | `dirTreeGenerator.generateTree(options.includeDirTree)` | 返回 `string|null`；已格式化为缩进文本 |
[93] | ④ 文件写盘 | （新增） | `fileOutput(md, npmlFilePath)` | 纯函数，无其他功能依赖 |
[94] 
[95] --------------------------------------------------
[96] 五、错误处理策略
[97] --------------------------------------------------
[98] - 任何依赖返回 `null` 即视为“不可恢复的业务错误”，本类立即短路返回 `null` 并打印 `[Error] xxx`。  
[99] - 剪贴板写入失败视为“可选能力失败”，同样返回 `null`（符合需求文档“任意错误即整体失败”）。  
[100] - 磁盘写入失败由 `fileOutput` 抛出异常，交由上层 CLI 捕获并退出非零状态。  
[101] 
[102] --------------------------------------------------
[103] 六、未来扩展点
[104] --------------------------------------------------
[105] 1. 剪贴板实现：  
[106]    待 `Deno` 官方或社区提供跨平台 clipboard API 后，替换 `console.log` 占位即可。  
[107] 2. 输出格式：  
[108]    目前章节顺序固定（NPML代码 → 项目结构 → 引用内容），后续可通过新增 `GenerationOptions.outputTemplate` 支持自定义模板。  
[109] 3. 增量更新：  
[110]    若 `.npml` 文件较大，可考虑缓存已读取的引用文件，对比时间戳做增量刷新。
---
// deno.json
[1] {
[2]   "tasks": {
[3]     "dev": "deno run --watch main.ts",
[4]     "build-main":"deno compile -A -o bin/npml main.ts"
[5]   },
[6]   "imports": {
[7]     "@std/assert": "jsr:@std/assert@1",
[8]     "@std/fs": "jsr:@std/fs@^1.0.21",
[9]     "@std/path": "jsr:@std/path@^1.1.4"
[10]   }
[11] }
[12] 
---
// docs/about_npml.md
[1] 《NP-Middle-Language》项目文档
[2] 一、项目概述
[3] 1.1 项目背景
[4] 大模型时代，AI编程、Vide coding成为新型编程范式——采用自然语言与编程AI助手交流，实现编程任务。整体来看，该编程范式直接通过自然语言编程，间接地将自然语言提升为“编程语言”，极大地降低了开发门槛。
[5] 但是自然语言天生不是为编程服务的，换句话说，自然语言难以描述复杂的程序逻辑，自然语言的细腻程度难以在编程语境下掌握——是宏观地描述具体需要实现的功能？还是微观地描述功能如何实现？同时，自然语言的歧义性导致每次AI生成的代码程序是不一致的，即“自然语言编程”难以实现唯一性。
[6] 总的来说，自然语言编程有以下局限性：
[7] 1.自然语言难以描述复杂程序逻辑；
[8] 2.自然语言难以把握描述细腻程度；
[9] 3.自然语言具有歧义，无法保证每次代码生成是确定的。
[10] 1.2 项目目标
[11] 本项目为了解决1.1所述的3个自然语言编程局限性，提出一种介于自然语言和高级编程语言的新编程语言，或者说标记语言，命名为NP-middle-Language。
[12] 该语言一定程度上可以视为编程语言，也可以称为标记语言，为了统一，本项目将该语言视为编程语言。
[13] NP-Middle-Language（下文简称NPML）将混合自然语言和一定高级编程语言语法，理论上具备自然语言的自由性和高级编程语言的严谨性。NPML的目的是引导编程AI生成无歧义、确定的高级编程语言代码。
[14] NPML与伪代码相似，但是NPML比高级编程语言更简单，比伪代码更灵活。
[15] 
[16] 二、NPML的基本概念
[17] 2.1 翻译器
[18] 每门编程语言都有其编译器或者解释器，对于静态语言，一般通过编译器编译为可执行文件（C/C++、golang、rust）；对于动态语言，一般通过解释器翻译为字节码，在运行时上运行（java、python）。
[19] NPML的编译器或者解释器直接来讲应该是AI本身，更具体一点：可生成目标高级编程语言的文字大模型。为了方便，本项目将该文字大模型称为编程AI。编程AI将NPML翻译为对应目标高级编程语言，然后调用该高级编程语言的编译器或者解释器。
[20] NPML翻译器定义为：可以将NPML代码转化为目标编程语言的编程AI。
[21] 2.2 弱语法约束
[22] NPML不是严格意义上的编程语言，而是混合自然语言和编程语言的标记类语言，也就是说NPML没有强力的语法约束，也不关心语法导致的程序安全、效率问题，只关注：程序的执行效果和程序的执行流程方式。
[23] 三、NPML设计
[24] 3.1 项目架构
[25] 每个项目开始时都需要确定整个项目的架构，具体而言就是项目的目录结构。为了引导翻译器感知整个项目架构，和正确生成代码文件，NPML引入项目架构描述文件：npml_arch.md。
[26] 架构描述文件里面会指明当前项目的目录架构，包括有哪些文件夹、文件，新的文件夹和文件应该放在哪里。文件夹和文件的命名约定。
[27] 架构描述文件有开发者和翻译器共同维护，需要定期及时更新，防止翻译器误解项目架构。
[28] 3.2 NPML优化
[29] 翻译器生成代码后，可以反向优化原NPML代码，使更符合代码，保持一致性。
[30] 
[31] 
[32] 四、NPML翻译器
[33] 4.1 目前结合智能体Agent的翻译器问题
[34] 经过实际开发，发现结合编程智能体Agent实现的NPML翻译器有诸多问题，其中是Agent自身的问题，还有是NPML翻译器设计问题。
[35] 一是Agent的主观能动性过高，不遵从最小实现原则，脱离NPML代码实现多余的功能。二是Agent在非热门的框架使用上，效果很差。三是文档引用语法不合理，使用不清晰。四是Agent模式可能不适合作为翻译器。
[36] 4.2 解决方案
[37] 对于问题一，实际上与问题四是同一类问题：Agent模式不适合作为NPML的翻译器。翻译器只需要实现如下功能：接收NPML代码和其引用文件（文档、其他代码），翻译并输出目标编程语言代码（或者文件），反向优化NPML代码。
[38] Agent模式能够实现翻译器的功能，但是它不只是能够实现翻译器的功能，它还具备自主工具使用、环境感知等，过高的主观能动性影响类翻译器的本质功能。所以Agent模式不适合作为NPML的翻译器。
[39] 事实上，只需要将NPML代码和其相关文件一起发送给翻译器即可，而发生内容的构建可以由程序实现。
[40] 对于问题二和问题三，需要增强文档的导入，丰富文档库，保证翻译器正确感知整个项目和框架的使用。
[41] 4.3 NPML翻译请求文（NPML request context）
[42] 本项目将NPML翻译器的职责进行精简，现在翻译器的任务为：接收NPML代码，输出NPML翻译请求文。将该NPML翻译请求文提交给任意擅长CODE的大模型AI，AI即可生成目标编程代码。用户可以自行创建从NPML代码到目标编程代码的端到端程序，只需要在翻译器下游添加对应程序即可。
[43] NPML翻译请求文默认以markdown方式存储，这符合人类阅读，也方便AI解析。NPML翻译请求文的内容如下：
[44] NPML代码；
[45] 项目结构说明；
[46] 文档引用；
[47] 代码引用。
[48] 
[49] 上面的四个子内容开头为对应子内容标题加冒号，正文下一行。
[50] 同一子内容里面的多个代码、文档用---隔开，并在开头以//[文件路径/文件名]指明文件名。
[51] 项目结构说明即项目目录树，由程序自动生成。
[52] 4.4 翻译流程
[53] 首先给NPML代码标上行号，便于AI定位行号；
[54] 将NPML代码中出现的引用语法标识!(file_path)中的引用内容添加到后续的文档引用或者代码引用中；
[55] 生成项目目录树作为项目结构说明。
[56] 
